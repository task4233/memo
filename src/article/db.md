---
date: 2019-03-19
description: 'デスペめも'
category: 
 - memo
 - デスペ
---

# デスペめも

# 03/15
# 1章 SQL
## SELECT
 - 選択する句
### 射影と選択
 - 射影はcolumnを抜き出す
     - SELECT A1,A2,... FROM R
 - 選択はrowを抜き出す
     - SELECT * FROM R WHERE X 比較演算子 Y

### 選択項目リスト
 - 算術演算子
     - +,-.*,/を使用できる
 - 連結演算子
     - ||で要素を連結できる
 - 別名(相関名)の指定
     - AS句は省略可能
 - 重複の除去
     - SELECTの直後にDISTINCT句を入れる
 - NULL処理
     - COALESCE句を使用する
     - isNotNull?(a:b)とCOALESCE (a,b)が同義
 - 条件式(CASE文)
     - CASE WHEN 条件式 THEN 文 ELSE 文 END

### notes
 - COUNTはstd::mapのような感じ
 - NULLの時にカウントされない
 - SQLは3値論理(True/False/Unknown(不定))
## WHERE
 - 条件指定する句
### BETWEEN
 - 閉区間の範囲指定
 - BETWEEN A AND Bで[A,B]の閉区間となる
### IN
 - 値の完全一致
 - IN (A, B)で==A || ==Bと同義
### LIKE
 - 文字列の部分一致
 - %は*と同義(ワイルドカード)
 - _は任意の1文字

|記法|意味|
|:-:|:-:|
|`LIKE 'hoge%'`|前方一致検索|
|`LIKE '%hoge'`|後方一致検索|
|`LIKE '%hoge%'`|中間一致検索|

### NULL
 - ISNULLでNULLの抜き出し

### NOT
 - NOTで否定
 - `<>`はNOTと同義

## GROUP BY
 - 結果を集約する句
### 集約関数

|関数|補足|
|:-:|:-:|
|AVG(列名)|平均|
|MAX(列名)|最大値|
|MIN(列名)|最小値|
|SUM(列名)|総和|
|COUNT(\*)|行数を数える(std::map)|
|COUNT(DISTINCT 列名)|列名を指定して, その列の重複値を除く行数を求める|

### 使用例
#### 通常時
 - 年齢をグループ化して各年齢の人数合計を求める時は, 次のように書く

```sql
SELECT age, SUM(age) AS age_cnt
    FROM measured_data
    GROUP BY age
```
 - GROUP BYを使用する時, 次の値のみしかSELECTできない
     - GROUP BYの後に指定した列
     - 集約関数
     - 定数

#### HAVING句を使用する時
 - GROUP BYの結果に対してvalidationを指定したい場合は, HAVING句の後に条件式を指定する
 - 同じ年齢の人間が5人以上いる時のみ表示する時は, 次のように書く

```sql
SELECT age, SUM(age) AS age_cnt
    FROM measured_data
    GROUP BY age
    HAVING COUNT(*) >= 3
```

### ORDER BY
 - 整列する句
#### 使用例
 - 年齢をグループ化して各年齢の人数合計を求め, 年齢について降順で表示する時は, 次のように書く

```sql
SELECT age, SUM(age) AS age_cnt
    FROM measured_data
    GROUP BY age
    ORDER BY age DESC
```

 - 年齢をグループ化して各年齢の人数合計を求め, 年齢について昇順で表示する時は, 次のように書く

```sql
SELECT age, SUM(age) AS age_cnt
    FROM measured_data
    GROUP BY age
    ORDER BY age (ASC) -- ASCは省略可能
```

 - 年齢をグループ化して各年齢の人数合計を求め, 合計人数について昇順で表示する時は, 次のように書く

```sql
SELECT age, SUM(age) AS age_cnt
    FROM measured_data
    GROUP BY age
    ORDER BY 2 DESC -- SELECTで設定したもの内2番目(SUM(age))のこと
```

### 結合
#### 内部結合と外部結合
|名称|補足|
|:-:|:-:|
|内部結合|A AND B|
|左外部結合|A|
|右外部結合|B|
|全外部結合|A OR B|

#### 等結合と自然結合
 - いずれも, rowが同じ要素を結合する
 - 等結合は, そのままくっつける
 - 自然結合は, 同じ列を重複して表示しない
 - e.g.)
 - 以下の表を年齢で結合する時

|年齢|体重|
|:-:|:-:|
|10|40|
|11|50|
|12|55|


|年齢|足のサイズ|
|:-:|:-:|
|10|18|
|11|20|
|12|22|

 - 等結合の場合

|年齢|体重|年齢|足のサイズ|
|:-:|:-:|:-:|:-:|
|10|40|10|18|
|11|50|11|20|
|12|55|12|22|

 - 自然結合の場合

|年齢|体重|足のサイズ|
|:-:|:-:|:-:|
|10|40|18|
|11|50|20|
|12|55|22|

### 和・差・直積・積・商
 - 集合RとSについて考える
#### 和
 - R $\cup$ S
 - UNIONで和を表す
 - UNION ALLと書くと重複を許す

#### 差
 - R-S
 - EXCEPTで差を表す

#### 直積
 - R $\times$ S

#### 積
 - R $\cap$ S
 - INTERSECTで積を表す

#### 商
 - R $\div$ S
     - $\exists$ T, S $\times$ T = R $\Rightarrow$ R $\div$ S = Tと定義する


# 03/18
## H30 午後1-1
## リレーションの矢印について
 - $A \rightarrow B$のとき, $A:B = 1:$多
 - 矢印の先が多
 - 記載がない場合は1:多

## サブタイプとスーパータイプ
 - 汎化した側のエンティティをスーパータイプという
 - 特化した側のエンティティをサブタイプという
 - 例えば, 料理というスーパータイプに対して, 和食セットや洋食セット, デザートコースといったサブタイプが存在する

## 排他的サブタイプと共存的サブタイプ
 - サブタイプが共通部分を持つときには共存的サブタイプに分類され, 共通部分を持たないとき排他的サブタイプに分類される
 - 例えば, セット類とサービス対象類というスーパータイプが存在したとき, 和食セットがサービス対象ならばこれはキュゾン的サブタイプに分類される
 - 要するに, 複数のスーパータイプに属することができる場合, 共存的サブタイプに分類されるわけだ

 - 「〜で分類」や「どちらか一方にしか存在できない」, 「両方に属するものは損じ足ない」という文言がある場合は, 排他的サブタイプに分類される

# 記述から読み取れるエンティティと属性
 - 「〜で分類」$\rightarrow$ サブタイプの切り口
   - AをBで分類 
     - AにはBが必要
     - エンティティAの属性としてBが挙げられる
 - 「〜で分類」(サブタイプ無しver.) $\rightarrow$ ただの属性として持たせる
   - AをBで分類
     - エンティティAの属性としてBを持たせる
 - 「〜で登録する」$\rightarrow$ 属性として持たせる
   - AにはBを登録する
     - エンティティAの属性としてBを持たせる

# キー
## スーパーキー(Super Key)
 - タプルを一意に識別できるキーのこと
 - 候補キーに, 様々な組み合わせで他の属性を付け足したもの
   - 冪集合のようなもの

## 候補キー(Candidate Key)
 - 次の2つの制約を持つ
   - タプルを一意に識別できること
   - スーパーキーの中で極小(それ以上分解できないもの)
     - 極小とは, 余計な属性を含まないもの
     - それ以上属性を減らすとタプルの識別ができなくなってしまうもの

## 主キー(Primary Key)
 - 次の2つの制約をもつ
   - 一意性制約
   - 非ナル(NULLが認められない)
 - 候補キーの中から元もふさわしいものが選ばれる

## 代理キー(Alternate Key)
 - 候補キーの中で主キーに選ばれなかったキー

## 小まとめ
 - 主キー $\in$ 候補キー $\subset$ スーパーキー

## サロゲートキー(Surrogate Key)
 - 連番がよく使用される
 - 一意性を確保して主キーとして使用されるためだけに使用される
 - 次のような場合に使用される
   - 主キーが複合キーの場合
     - 主キーが複数の属性で構成されていると扱いづらい
     - そのため, 主キーの代わりにサロゲートキーが用いられることがある
   - データウェアハウスで, 長期間の履歴を管理したい場合
     - 主キーはstringになることがあるが, integerで管理した方が楽
     - 数字列なので一意性が損なわれづらい

## 外部キー
 - 他のリレーションの主キー(または候補キーでも良い)を参照する項目のこと
 - エンティティA,Bについて, A-Bという1:1のリレーションがあるとする
 - このとき, Aの主キーpを参照するBの外部キーqが存在するとする
 - Aの主キーpには実線で下線が引かれる
 - Bの外部キーqには破線で下線が引かれる

# 03/19
## H30 午後1-2
## SQL
 - CURRENT_DATE値関数によって現在日時を示すDATE型の値が取得できる
 - DISTINCT句で重複を解消できる
 - GROUP BY句の後に来れるのはHAVING句かORDER BY句
   - グループ化した後に条件があればHAVING句
   - グループ化した後にソートされていればORDER BY句
     - ASCは昇順, DESCは降順
     - ASCは省略可能
## 参照制約
 - テーブルとテーブルが参照関係にある場合の整合性制約
 - 参照元テーブルに外部キーを指定することで, テーブル間の整合性を保つ

|OPTION|詳細|
|:-:|:-:|
|NO ACTION|参照元テーブルにデータが存在している場合, 参照先テーブルでは削除と更新ができない|
|''|オプションを設定しない場合, NO ACTIONに設定される|
|CASCADE|参照元テーブルにデータが存在している場合でも, 参照先テーブルで削除と更新ができる|
|''|データは連携して削除される|
|SET NULL|参照元テーブルにデータが存在している場合でも, 参照先テーブルで削除と更新ができる|
|''|参照元テーブルのデータはNULLに設定される|

 - 参照先テーブルに関して(raw data)
   - 行を追加することは問題ない
   - 行を削除する場合に, 参照元テーブルの外部キーに同じ値が存在している場合, 削除はできない
     - 参照関係が存在している場合に削除はできない
   - ある行を更新する場合, 参照先テーブルの外部キーに存在する値への更新なら可能になる
 - 参照元テーブルに関して(instance data)
   - 行を削除することは問題ない
   - 行を追加する場合に, 参照先テーブルに存在するものかNULLしか追加できない
   - 行を更新する場合に, 更新後の値が参照先テーブルに存在する値にしか更新できない
 